## 1. 模板起源

### C语言的中的宏

- 预处理阶段进行纯文本替换
- 不会进行数据类型检查

### 利用宏构建通红函数框架（宏和函数组合在一起）

- 通过实例化宏， 让预处理器将这个宏带换成针对不同数据类型的真正函数

- 将宏的通用性和函数的类型安全性结合

  ```c++
  #define MAX(T) T max_##T(T x,T y){\
  					return x>y?x:y;
  				\}
  				
  MAX(int)//由预编译器生成的函数定义
  // int max_int(int x,int y){return .....}
  
  #define Max(T) max_##T
  
  int main()
  {
  	Max(int)(10,20);
  }
  ```



## 2. 函数模板

### 定义

- 形式

  ```c++
  template<class 类型形参1, class 类型形参2,...>
  返回值类型 函数模板名（调用形参1, 调用形参2,...）
  {
  ...
  }
  ```

  

### 使用

- 必须先实例化
- 函数模板名<类型**实参**1，类型**实参**2, ...>(调用**实参**1，调用**实参**2，...);

### 分析(本质)

- 编译器在看到实例化后(使用函数模板), 会根据类型实参从函数模板中产生一个真正的函数实体

### 实例化的条件

类型必须支持函数模板要执行的操作，（比如 >, 不是所有自定义类型都支持）

### 拓展

- 二次编译

  - 实例化之前
    - 模板内部是否所有标识符都有声明
    - 对已知类型的调用是否有效
    - 对未知类型的调用默认有效,  **但是<> 除外**
  - 实例化之后
    - 查看是否所有调用都有效

- 隐式推断类型实参

  如果调用形参和类型形参相关，那么在实例化函数模板时即使不显式指明类型实参，编译器也可以根据调用实参的类型推断出类型实参的类型。

  **以下3种不支持隐式推断**

  - 调用参数和类型参数不完全相关

    ```c++
    template<class T, class D> T Max(T x,T y){}
    ```

  - 隐式推断不支持隐式类型转换

    ```c++
    Max(123,34.0);
    ```

    但是可以

    ```c++
    Max(123,(int)34.0);
    ```

  - 返回值类型不支持饮食推断

- 重载

  - 普通函数和可实例化出该函数的函数模板构成重载关系

    在数据类型匹配度相同的情况下，编译器优先选择普通函数

  - 函数模板的实例化不支持隐式转换，如果传递参数是需要编译器做隐式转换，则编译器选择普通函数

  - 在实例化时，可以用<> 强行使用函数模板

    

## 3. 类模板

### 类模板声明

``` c++
template <class 类型形参1 ...> class 类模板名 {...}
```

类模板可以声明在头文件，实现放在源文件

``` c++
tamplate <class T> T Cmath<T>::add(){}
```

### 类模板使用

- 类模板被实例化时，类模板中的成员函数并没有被实例化，成员函数只有在被调用的时候才会被实例化，**成员虚函数除外**

### 类模板的静态成员

- 类模板的静态成员不是每一个对象拥有一份，也不是类模板拥有一份，而是有类模板实例化出的每一个类各拥有一份，且为该实例化类定义的所有对象共享

### 类模板的递归实例化

- 可以使用任何类型来实例化模板
- 由类模板实例化产生的类也可以用来实例化类模板自身， 叫做类模板的递归实例化
- 通过这种方法可以构建空间上具有递归特征的数据结构 （比如：多维数组）



## 4. 类模板扩展

### 全局特化

- 全类特化：特化类模板的所有成员函数, 相当于重写了一个针对某种特定数据类型的具体类

  ```c++
  template<> 
  class Cmath<float>
  {
  ...
  }
  
  ```

- 成员特化: 如果只有某个成员不行就特化整个模板，代价太大，所有有了成员特化

  ```c++
  template<>
  char* const CMath<char* const>::add(){...}
  ```



### 局部特化

只特化一部分类型参数

```C++
template< class T, class D> 
class Cmath{...};

// 局部特化
template<class T> 
class Cmath<T,float>{...};

// 也是局部特化，要求两个类型一致
template<class T> 
class Cmath<T,T>{...};

// 也是局部特化
template<class T, class D> 
class Cmath<T*, D*>{...};
```

- 除非必要，否则尽量不要特化，因为特化版本过多容易引发编译器匹配歧义

  

### 类型形参的缺省

- 类模板的**类型形参**可以带缺省值， 实例化时，如果提供了**类型实参**，则用所提供的类型实参来实例化。如果没有提供类型实参，则用相应的**类型形参的缺省类型**来实例化类模板

   ```c++
   template< class T = int, class D = float> //设置了类型形参的缺省类型
   class Cmath{...};
   ```

  

### 数值形（整形）的模板参数()

- 类模板的模板形参并不限于类型参数，普通数值也可以作为模板的参数

   ```c++
   template <class T, size_t S=15> 
   class Array
   {
   	T m_array[S];
       size_t size(){return S;};
   } 
   
   Array<int,10> a;
   ```

  

### 模板技巧

- 模板型成员变量 ：成员变量， 但是类型是由一个类模板实例化的未知类

  ```c++
  template<class T> 
  class Array{..};
  
  template<class D>
  class Sum
  {
  	Array<D> m_s;//模板类型成员变量
  } 
  ```

  

- 模板型成员函数：类模板的成员函数模板

  ```c++
  template<class T>
  class Cmath
  {
      template<class D> void foo(){...}
  }
  
  // 如果在类外实现
  
  template<class T>
      template <class D>
  	void Cmath<T>::foo(){...};
  ```

  

- 模板型成员类型： 类模板中嵌套的类模板

  ```c++
  template<class X>
  class A{
  	template<class Y> class B{...};
  };
  
  ```

  

- 模板型模板参数 ： 模板的模板形参 也可以是类模板，可以有缺省值



## 5. 典型错误

### 嵌套依赖

```c++
class A
{
public:
    class B
    {
    public:
        void foo(){}
    };
};

template<class T> 
void Func()
{
    T::B b;// 嵌套依赖， 编译器会把 T::B 理解成是 B 是 T 的静态成员变量
    typename T::B b; //改正
    b.foo()
}
```



- 问题: 

  由于模板要经历两次编译，在**第一次编译**代码时，类型形参的具体类型尚不明确，编译器将把类型形参（T）的嵌套类型（B）**理解为某个未知类型的静态成员变量**（T::B），因此编译器看到使用这样的标识符声明变量时会报告错误

- 解决：

  在类型形参的前面增加一个typename标识符，告诉编译器其后是一个类模板的嵌套使用

  

### 依赖 模板参数 访问 成员函数模板

```c++
class A
{
public:
   template<class T> 
   void foo(){}
};


void Func()
{
	D d;
	d.foo()<float>();// 错误
    d.template foo<int>();// 改正
}
```



- 问题： 利用未知类定义的对象来访问成员函数模板时，编译器在**第一次编译时**，**无法解析成员函数模板**的类型参数列表的**<>**而报告编译错误。 **编译器第一次编译时无法理解 <>**
- 解决：在成员函数模板之前增加template关键字，告诉编译器其后是一个函数的模板实例，编译器就可以正确理解<>

### 子模板访问基模板

只有类才有继承，类模板没有继承

```c++
template<class T>
class Base
{
public:
   int i; 
   void foo(){}
};

template <class T, class D> 
class Derived : public Base<T>// 继承自未知类
{
 public:
    void bar(){i=100;foo();}  //错误
    void bar(){Base<T>::i=100; Base<T>::foo();}  //改正 1: Base<T>未知类，未知类型调用->编译器会隐忍
    void bar(){this->i=100; this->foo();}  //改正 2: this 为子类，也是未知类，未知类型调用->编译器会隐忍
    
}
```



- 问题：

  在子类模板中访问基类模板的成员，编译器**第一次编译**时只会在子类模板和全局中搜索使用的标识符符号，不会到基类模板中搜索

- 解决：

  在子类模板中可以通过使用**作用域限定符**或显示使用**this指针**

### 零值初始化

**编译器不会报错，就是基本类型会出现问题**

- 问题：

  - 基本类型不存在缺省构造函数，未被初始化的局部变量都有一个**不确定的值**

  - 类类型由于存在缺省构造函数，未被初始化的情况下可以有一个**确定的缺省初始化状态**

  基于上述两点，就会在模板实现中产生不一致的语法语义

- 解决：

  如果希望模板中，所有类型参数的变量，无论是类类型还是基本类型都以缺省方式获得初始化，就必须对其进项**显式的缺省构造T()**

### 类模板中的成员虚函数

- 类模板中的普通成员函数可以是虚函数

  即可以为类定义成员虚函数，和普通类的成员虚函数一样，**类模板的成员虚函数也可以表现出多态性**

- 类模板中的 成员函数模板 不可以是虚函数

  根据成员虚函数的多态机制，需要一个虚函数表，而这个**虚函数表是编译器在实例化类模板是就生成**，

  而类的成员函数模板的实例化需要编译器处理完调用后才会生成，这是才出现成员虚函数的地址

- 成员函数模板的延迟编译阻碍了虚函数表的静态构建 

















